'use strict';

const assert = require('assert');

const jwkAllowedAlgorithms = require('jwk-allowed-algorithms');
const jwkToPem = require('jwk-to-pem');
const jws = require('jws');
const request = require('superagent');

const AuthToken = require('brightspace-auth-token');

const errors = require('./errors');

const DEFAULT_ISSUER = 'https://auth.brightspace.com/core';
const DEFAULT_MAX_CLOCK_SKEW = 5 * 60;
const DEFAULT_MAX_KEY_AGE = 5 * 60 * 60;
const JWKS_PATH = '/.well-known/jwks';

function clock() {
	return Math.round(Date.now() / 1000);
}

function processJwks(jwks, knownPublicKeys, maxKeyAge, skew) {
	assert('object' === typeof jwks);
	assert(Array.isArray(jwks.keys));
	assert(knownPublicKeys instanceof Map);
	assert('number' === typeof maxKeyAge);
	assert('number' === typeof skew);

	const
		currentPublicKeys = new Map(),
		expiry = clock() + maxKeyAge;

	for (const jwk of jwks.keys) {
		assert('object' === typeof jwk);
		assert('string' === typeof jwk.kid);

		const pem = knownPublicKeys.has(jwk.kid)
			? knownPublicKeys.get(jwk.kid).pem
			: jwkToPem(jwk);
		const allowedAlgorithms = jwkAllowedAlgorithms(jwk);

		const keyExpiry = typeof jwk.exp === 'number'
			? jwk.exp + skew
			: expiry;

		if (clock() >= keyExpiry) {
			continue;
		}

		currentPublicKeys.set(jwk.kid, {
			expiry: keyExpiry,
			pem: pem,
			allowedAlgorithms: allowedAlgorithms
		});
	}

	return currentPublicKeys;
}

class AuthTokenValidator {
	constructor(opts) {
		opts = opts || {};

		this._maxClockSkew = DEFAULT_MAX_CLOCK_SKEW;
		const maxClockSkewOpt = opts.maxClockSkew;
		if ('undefined' !== typeof maxClockSkewOpt) {
			if ('number' !== typeof maxClockSkewOpt || maxClockSkewOpt < 0) {
				throw new TypeError(
					`Expected "opts.maxClockSkew" to be a non-negative Number. Got "${ maxClockSkewOpt }" (${typeof maxClockSkewOpt}).`
				);
			}
			this._maxClockSkew = maxClockSkewOpt;
		}

		const issuer = 'string' === typeof opts.issuer ? opts.issuer.replace(/\/+$/g, '') : DEFAULT_ISSUER;

		this._jwksUri = `${ issuer }${ JWKS_PATH }`;
		this._maxKeyAge = 'number' === typeof opts.maxKeyAge ? opts.maxKeyAge : DEFAULT_MAX_KEY_AGE;
		this._keyCache = new Map();
		this._keysUpdating = null;
	}

	async fromHeaders(headers) {
		assert('object' === typeof headers);

		const authHeader = headers.authorization;
		if (!authHeader) {
			throw new errors.NoAuthorizationProvided();
		}

		const signatureMatch = authHeader.match(/^Bearer\s+(.+)$/);
		if (!signatureMatch) {
			throw new errors.NoAuthorizationProvided();
		}

		const signature = signatureMatch[1];

		return this.fromSignature(signature);
	}

	async fromSignature(signature) {
		assert('string' === typeof signature);

		const token = decodeSignature(signature);
		const claims = this._validateClaims(token);
		const publicKey = await this._getPublicKey(token);

		verifySignature(signature, token, publicKey);

		return new AuthToken(claims, signature);
	}

	async validateConfiguration() {
		await this._updatePublicKeys();

		return true;
	}

	_validateClaims(token) {
		const claims = token.payload;
		const now = clock();

		if ('undefined' !== typeof claims.exp) {
			const exp = claims.exp;
			if ('number' !== typeof exp) {
				throw new errors.BadToken('Invalid "exp" claim');
			}

			const diff = now - exp;
			if (diff >= this._maxClockSkew) {
				throw new errors.BadToken(`Token expired (${diff} seconds)`);
			}
		}

		if ('undefined' !== typeof claims.nbf) {
			const nbf = claims.nbf;
			if ('number' !== typeof nbf) {
				throw new errors.BadToken('Invalid "nbf" claim');
			}

			const diff = now - nbf;

			if (diff < -1 * this._maxClockSkew) {
				throw new errors.BadToken(`Token not yet valid (${diff} seconds)`);
			}
		}

		return claims;
	}

	async _getPublicKey(token) {
		assert('object' === typeof token);
		assert('object' === typeof token.header);

		const kid = token.header.kid;

		assert('string' === typeof kid);

		if (this._keyCache.has(kid)) {
			const publicKey = this._keyCache.get(kid);

			if (clock() < publicKey.expiry) {
				return publicKey;
			}
		}

		await this._updatePublicKeys();

		if (this._keyCache.has(kid)) {
			return this._keyCache.get(kid);
		}

		throw new errors.PublicKeyNotFound(kid);
	}

	async _updatePublicKeys() {
		if (!this._keysUpdating) {
			this._keysUpdating = this._updatePublicKeysInner();

			try {
				await this._keysUpdating;
			} finally {
				this._keysUpdating = null;
			}
		}

		return this._keysUpdating;
	}

	async _updatePublicKeysInner() {
		const jwks = await new Promise((resolve, reject) => {
			request
				.get(this._jwksUri)
				.end(function(err, res) {
					if (err) {
						reject(new errors.PublicKeyLookupFailed(err));
						return;
					}

					resolve(res.body);
				});
		});

		this._keyCache = processJwks(jwks,
			this._keyCache,
			this._maxKeyAge,
			this._maxClockSkew
		);
	}

}

function decodeSignature(signature) {
	assert('string' === typeof signature);

	let decodedToken = null;
	try {
		decodedToken = jws.decode(signature);
	} catch (e) {
		throw new errors.BadToken('Not a valid JWT');
	}

	if (!decodedToken) {
		throw new errors.BadToken('Not a valid JWT');
	}

	const header = decodedToken.header;

	if ('string' !== typeof header.kid) {
		throw new errors.BadToken('Missing "kid" header');
	}

	if ('string' !== typeof header.alg) {
		throw new errors.BadToken('Missing "alg" header');
	}

	return decodedToken;
}

function verifySignature(signature, token, publicKey) {
	const alg = matchAlgorithm(publicKey, token);

	let verified = false;
	try {
		verified = jws.verify(signature, alg, publicKey.pem);
	} catch (e) {
		throw new errors.BadToken('Error during signature verification');
	}

	if (!verified) {
		throw new errors.BadToken('Invalid signature');
	}
}

function matchAlgorithm(publicKey, token) {
	const requestedAlgorithm = token.header.alg;
	const allowedAlgorithms = publicKey.allowedAlgorithms;

	if (-1 === allowedAlgorithms.indexOf(requestedAlgorithm)) {
		throw new errors.BadToken('Token listed bad algorithm for key, "' + requestedAlgorithm + '"');
	}

	return requestedAlgorithm;
}

module.exports = AuthTokenValidator;
module.exports.errors = errors;
