'use strict';

const
	sinon = require('sinon'),
	chai = require('chai'),
	assert = require('chai').assert,
	DynamoDbLocal = require('dynamodb-local'),
	AWS = require('aws-sdk'),
	chaiAsPromised = require('chai-as-promised');

const
	DynamoPublicKeyStore = require('../src/public-key-store'),
	clock = require('../src/clock');

chai.use(chaiAsPromised);

describe('public-key-storeintegration tests', function() {
	const expectedPublicKey = JSON.stringify({
		kid: 'TestPublicKey'
	});

	const dynamoLocalPort = 8000;
	const expiryTime = clock() + 10000;
	const oldExpiryTime = clock() - 10000;
	const tableName = 'test_auth_public_keys';

	let provisioner;
	let db;

	before(() => {
		return DynamoDbLocal.launch(dynamoLocalPort, null, ['-sharedDb']).then(() => {
			db = new AWS.DynamoDB({
				endpoint: new AWS.Endpoint(`http://localhost:${dynamoLocalPort}`),
				accessKeyId: 'test',
				secretAccessKey: 'test',
				region: 'test'
			});
			return DynamoPublicKeyStore.createTable(db, tableName).then(() => {
				provisioner = new DynamoPublicKeyStore(
					db,
					tableName
				);
			});
		});
	});

	afterEach(() => {
		return db.deleteTable({
			TableName: tableName
		}).promise().then(() => {
			return DynamoPublicKeyStore.createTable(db, tableName);
		});
	});

	after(() => {
		DynamoDbLocal.stop(dynamoLocalPort);
	});

	it('calling create table does nothing if it already exists', () => {
		return DynamoPublicKeyStore.createTable(db, tableName).then(() => {
			return DynamoPublicKeyStore.createTable(db, tableName);
		});
	});

	it('stores the public key into the AUTH_PUBLIC_KEYS table', () => {
		return provisioner._storePublicKey(expectedPublicKey, expiryTime)
			.then(() => {
				return provisioner._lookupPublicKeys();
			})
			.then(retrievedKeys => {
				assert.equal(retrievedKeys[0], expectedPublicKey);
			});
	});

	it('returns an empty array when the key expiryTime is too old', () => {
		return provisioner._storePublicKey(expectedPublicKey, oldExpiryTime)
			.then(() => {
				return provisioner._lookupPublicKeys();
			})
			.then(allPublicKeys => {
				assert.equal(allPublicKeys.length, 0);
			});
	});

	it('rejects the public-keystore promise when the database is down', () => {
		const dbSetStub = sinon.stub(db, 'putItem');
		const dbGetStub = sinon.stub(db, 'scan');
		const errorString = 'Database failure';
		const errorPromise = {promise: () => { return Promise.reject(errorString); } };
		dbSetStub.returns(errorPromise);
		dbGetStub.returns(errorPromise);
		const regexMatch = new RegExp(errorString); //chai-as-promised expects a RegExp to match on

		const storeFailure = assert.isRejected(
			provisioner._storePublicKey(expectedPublicKey),
			regexMatch
		);

		const lookupFailure = assert.isRejected(provisioner._lookupPublicKeys(), regexMatch);

		dbSetStub.restore();
		dbGetStub.restore();

		return Promise.all([
			storeFailure,
			lookupFailure
		]);
	});

	it('expired keys are not returned', () => {
		const existingTestKey = JSON.stringify({
			kid: 'TestExistingPublicKeys',
			exp: oldExpiryTime
		});

		return provisioner._storePublicKey(existingTestKey, oldExpiryTime)
			.then(() => {
				return provisioner._lookupPublicKeys();
			})
			.then(initialKeys => {
				assert.equal(initialKeys.length, 0);
			})
			.then(() => {
				return provisioner._storePublicKey(expectedPublicKey, expiryTime);
			})
			.then(() => {
				return provisioner._lookupPublicKeys();
			})
			.then(oneKey => {
				assert.deepEqual(oneKey[0], expectedPublicKey);
			})
			.then(() => {
				return provisioner._storePublicKey(expectedPublicKey, oldExpiryTime);
			})
			.then(() => {
				return provisioner._lookupPublicKeys();
			})
			.then(finalKeys => {
				assert.equal(finalKeys.length, 0);
			});
	});

});
